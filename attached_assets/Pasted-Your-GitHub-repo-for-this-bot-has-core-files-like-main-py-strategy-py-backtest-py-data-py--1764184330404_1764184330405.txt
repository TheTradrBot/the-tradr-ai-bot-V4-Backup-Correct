Your GitHub repo for this bot has core files like `main.py`, `strategy.py`, `backtest.py`, `data.py`, `indicators.py`, `trade_state.py`, plus the doc `strategy_analysis.md`.

Here’s a single master prompt you can paste into **Replit’s AI/Agent** inside that project.

You don’t need to edit anything, just paste this into the Agent:

````text
You are an expert quantitative trading systems engineer.

This Replit project is the **Blueprint-Tradr-AI-Bot**, cloned from:
- https://github.com/TheTradrBot/Blueprint-Tradr-AI-Bot

It already contains:
- `main.py`           → Discord bot / orchestration
- `strategy.py`       → current strategy implementation
- `backtest.py`       → existing backtest logic (to be upgraded)
- `data.py`           → data utilities
- `indicators.py`     → indicator + confluence helpers
- `trade_state.py`    → trade tracking / state
- `config.py`         → configuration
- `strategy_analysis.md` (and any other attached strategy docs)
Your job is to turn this into a **self-consistent strategy + backtest + optimizer loop** that can actually EVOLVE the strategy using historical data, then deploy that optimized logic back into the live bot.

==================================================
HIGH-LEVEL GOAL
==================================================

Using THIS bot and THIS codebase:

1. Run robust backtests for multiple assets and years (2018–2024).
2. Use those backtest results to **optimize/change the strategy** (logic + parameters) so that, per asset and per year, it aims to achieve:

   - **≥ 50 trades per year**
   - **Win rate between 70% and 100%**
   - **Yearly return ≥ +50%**

3. After optimization:
   - The **same optimized strategy** must be used for:
     - Backtests
     - Future live scans / setups / Discord outputs
   - The code and the documentation (`strategy_analysis.md`) must stay in sync.

These performance numbers are **historical optimization targets**, not future guarantees.

==================================================
1. UNDERSTAND CURRENT STRATEGY
==================================================

1. Carefully read `strategy_analysis.md` and any other strategy docs.
   - Understand the core Blueprint strategy: structure, confluence, fibs, S/D, liquidity, HTF vs LTF logic, etc.
   - Treat this as the conceptual blueprint.

2. Inspect these key modules in the repo:
   - `strategy.py`        → where the strategy rules are currently implemented
   - `indicators.py`      → indicator/confluence helpers
   - `trade_state.py`     → trade tracking / PnL logic
   - `data.py`            → data loading utilities
   - `backtest.py`        → current backtest implementation
   - `main.py`            → Discord bot, commands, live scanning

3. Identify:
   - Where setups/entries are detected.
   - How exits / SL / TP are implemented.
   - How confluence is calculated.
   - What parameters/thresholds already exist (risk, filters, R:R, etc.).

4. If there are mismatches between `strategy_analysis.md` and the code:
   - Note them.
   - Plan to bring them back in sync as part of the optimization pass.

==================================================
2. DATA & TIME RANGE
==================================================

We will backtest on **historical OHLCV data from 2018–2024**, evaluated **year-by-year**:

- Years: 2018, 2019, 2020, 2021, 2022, 2023, 2024.

Assets: create a configurable list, e.g.:

```python
ASSETS = [
  "EURUSD", "GBPUSD", "USDJPY",
  "XAUUSD", "XAGUSD",
  "USOIL",  "UKOIL",
  "SPX500", "NAS100",
  "BTCUSD", "ETHUSD", "SOLUSD"
]
````

(Use this as a default; make it easy for me to edit.)

Data assumptions:

* One CSV per asset in a `data/` folder (or reuse `attached_assets` if that’s already set up).
* Columns: `timestamp, open, high, low, close, volume`.
* Use the same timeframe that the strategy currently uses for its scans (e.g. H4 / H1). Infer this from the existing code and keep it identical.

Create or refactor in `data.py`:

```python
def load_ohlcv(asset: str) -> pd.DataFrame:
    """Load OHLCV for the given asset from /data."""
    
def filter_by_year(df: pd.DataFrame, year: int) -> pd.DataFrame:
    """Return only rows from the specified calendar year."""
```

Add clear comments on:

* Where I should put CSV files.
* How to name them (`EURUSD.csv`, `XAUUSD.csv`, etc.).

==================================================
3. BUILD A CLEAN BACKTEST ENGINE
================================

We must have a **single source of truth** for the trading rules that is used by both:

* Backtests
* Live scans / Discord outputs

Refactor as needed (without breaking the bot) so that:

1. In `strategy.py` (or a new `strategy_core.py` if you prefer), expose clean functions like:

```python
def generate_signals(candles: pd.DataFrame, params: dict) -> list:
    """
    Given OHLCV candles and strategy params, return a list of signal objects
    (entries/exits) according to the Blueprint strategy rules.
    """

def simulate_trades(candles: pd.DataFrame, params: dict) -> list:
    """
    Use the same logic as live trading / scanning, but run through historical
    candles and produce a list of Trade objects with PnL, win/loss, etc.
    """
```

2. The **Discord bot / live scanner** logic in `main.py` should call these same functions to find setups on live data.

3. In `backtest.py`, implement a robust function:

```python
def run_backtest(asset: str, year: int, params: dict) -> dict:
    """
    Uses the REAL strategy logic (not a simplified version) to backtest
    one asset for one year.

    Returns at least:
      - trades (int)
      - win_rate (0–1 float)
      - return_pct (e.g. 57.3 for +57.3%)
      - max_drawdown_pct (optional but useful)
      - expectancy_per_trade (optional)
    """
```

This function should:

* Load full history for that asset.
* Filter it to the requested year.
* Call the shared strategy functions in `strategy.py`.
* Track trades using `trade_state.py` (or refactor trade state so it’s reusable).
* Compute metrics and return them.

4. Add a helper to run baseline backtests for **all assets and years** and save results to something like `results_baseline.csv`.

==================================================
4. BASELINE RUN (NO OPTIMIZATION YET)
=====================================

Before changing the strategy:

1. Implement the baseline Blueprint strategy exactly as described in `strategy_analysis.md` (fix any mismatches).

2. Run backtests for all:

   * assets in `ASSETS`
   * years 2018–2024

3. Produce and save a baseline table:

* `asset, year, trades, win_rate, return_pct, max_drawdown_pct`

4. Print a readable summary (per asset) so we see where we are relative to the targets.

==================================================
5. STRATEGY + PARAMETER OPTIMIZATION
====================================

Now we want to **optimize the strategy itself**, not just a couple of knobs.

Optimization targets per ASSET-YEAR:

* `trades >= 50`
* `0.70 <= win_rate <= 1.00`
* `return_pct >= 50`

These are filters/objectives on historical results.

You are allowed to:

* Tune numeric parameters:

  * Risk per trade.
  * SL/TP multipliers, minimum RR.
  * Lookback windows.
  * Confluence thresholds.
  * Volatility/trend filters.
* Adjust rules while staying faithful to the Blueprint idea:

  * Modify how confluence is combined.
  * Change which conditions are mandatory vs optional.
  * Add/replace filters (e.g. HTF trend filter, S/R proximity filter) again grounded in the original Blueprint logic.

You are **not** allowed to:

* Introduce completely unrelated indicators or patterns that have nothing to do with the Blueprint strategy (keep it recognisable).
* Remove risk management.

Create an `optimizer.py` that:

1. Defines a **search space**:

   * Reasonable ranges for key parameters from `strategy.py` and `indicators.py`.
   * Optional boolean flags for certain rule variations.

2. For each candidate configuration (params + rule flags):

   * Run `run_backtest(asset, year, params)` for each asset and year.
   * Collect metrics in memory and/or save to `results_optimization.csv`.

3. Define an objective such as:

   * Primary objective: maximize the number of (asset, year) pairs that satisfy:

     * `trades >= 50`
     * `win_rate >= 0.70`
     * `return_pct >= 50`
   * Secondary objectives:

     * Maximize overall average `return_pct` across all asset-years.
     * Minimize average `max_drawdown_pct`.

4. From all tested configurations:

   * Identify one **global configuration** that works robustly across assets/years.
   * Optionally allow small per-asset overrides (but avoid heavy overfitting).

5. Save the best configs to `best_strategy_config.json`:

```json
{
  "global": {
    "param1": ...,
    "param2": ...,
    "rule_flags": { "use_trend_filter": true, "tight_sl": false }
  },
  "per_asset": {
    "EURUSD": { "param1": ..., "rule_flags": {...} },
    "XAUUSD": { "param1": ..., "rule_flags": {...} }
  }
}
```

==================================================
6. WIRE OPTIMIZED STRATEGY BACK INTO THE BOT
============================================

After choosing the best configuration:

1. Update `config.py` or a new `settings.py` so the bot can load `best_strategy_config.json` and use:

   * Global defaults.
   * Per-asset overrides where present.

2. Make sure that:

   * Live scanning / Discord commands in `main.py` call the SAME core functions in `strategy.py` using the optimized configuration.
   * There is no duplicated “old” vs “new” logic; everything should go through the optimized strategy path.

3. Optionally, allow a simple toggle, e.g.:

```python
USE_OPTIMIZED_STRATEGY = True
```

So I can quickly compare baseline vs optimized behavior.

4. Update `strategy_analysis.md` so that it describes the **final, optimized Blueprint strategy**:

   * Final entry rules.
   * Final exit rules.
   * Key filters and confluence logic.
   * Main parameters and their optimized values.
   * Any trade-offs or notes about robustness.

==================================================
7. REPORTING & HOW TO RUN
=========================

Create a `report.py` (or reuse `backtest.py` with a CLI) that:

* Loads the final best configuration and the optimization results.

* Prints, for each asset:

  `asset | year | trades | win_rate | return_pct | max_drawdown_pct | meets_targets (yes/no)`

* Shows summary stats:

  * How many years per asset meet all targets.
  * Overall averages.

At the end of your changes, please:

1. Explain the final project structure (what each key file does).

2. Show the main entrypoints and how to run them, for example:

   * Run baseline backtests:

     ```bash
     python backtest.py --mode baseline
     ```
   * Run full optimization:

     ```bash
     python optimizer.py
     ```
   * Show final report:

     ```bash
     python report.py
     ```
   * Start the Discord bot with optimized strategy:

     ```bash
     python main.py
     ```

3. Add comments/docstrings so that I can:

   * Adjust the assets list.
   * Change parameter ranges.
   * Add new years or data sources later.

Remember:

* Use the **existing Blueprint-Tradr-AI-Bot code** as the foundation.
* Make the backtest faithfully match the logic used by the bot.
* Use historical results from 2018–2024 to evolve the strategy toward:

  * ≥ 50 trades/year,
  * 70–100% winrate,
  * ≥ +50% yearly return (on backtest),
    while prioritizing robustness across assets and years over extreme overfitting.

```

You can now copy that whole block into the Replit Agent chat inside your Blueprint bot repl and let it go to work on this repo.
::contentReference[oaicite:1]{index=1}
```
